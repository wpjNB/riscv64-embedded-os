# RISC-V 64 位嵌入式操作系统架构

## 概述

本文档描述了 RISC-V 64 位嵌入式操作系统项目的架构。

## 系统架构

```
┌─────────────────────────────────────────┐
│          用户空间 (U-mode)              │
│  ┌───────────┐  ┌──────────────────┐   │
│  │   Shell   │  │   用户程序       │   │
│  └─────┬─────┘  └────────┬─────────┘   │
│        │                 │              │
│        └─────────┬───────┘              │
└──────────────────┼──────────────────────┘
                   │ 系统调用
┌──────────────────┼──────────────────────┐
│                  ▼                       │
│        内核空间 (S-mode)                │
│  ┌──────────────────────────────────┐   │
│  │        系统调用接口              │   │
│  └────────────┬─────────────────────┘   │
│               │                          │
│  ┌────────────┼─────────────────────┐   │
│  │  进程     内存      陷阱/中断    │   │
│  │  管理     管理      处理         │   │
│  └────────────┼─────────────────────┘   │
│               │                          │
│  ┌────────────┼─────────────────────┐   │
│  │       设备驱动                    │   │
│  │  UART  │  RTC  │  PLIC            │   │
│  └────────────┼─────────────────────┘   │
└───────────────┼──────────────────────────┘
                │ 硬件访问
┌───────────────┼──────────────────────────┐
│               ▼                          │
│        硬件 (M-mode/OpenSBI)            │
│  ┌─────────────────────────────────┐    │
│  │  CPU  │ 内存 │ UART │ RTC       │    │
│  └─────────────────────────────────┘    │
└──────────────────────────────────────────┘
```

## 启动序列

1. **上电 / 复位**
   - CPU 在复位向量处以 M-mode 启动
   - （在真实硬件上，M-mode 固件会运行）

2. **OpenSBI (M-mode)** - 在使用 QEMU 和 OpenSBI 时
   - 初始化硬件
   - 设置机器模式环境
   - 准备跳转到 S-mode

3. **Bootloader (S-mode)**
   - `boot.S`：入口点在 `_start`
   - 清除中断
   - 设置栈指针
   - 清除 BSS 段
   - 跳转到 `kernel_main`

4. **内核初始化**
   - 初始化 UART 用于控制台
   - 初始化内存管理器
   - 初始化陷阱处理器
   - 启动交互式 shell

## 内存布局

### 物理内存映射（QEMU virt 机器）

```
0x00000000 - 0x00000FFF    调试/启动 ROM
0x00001000 - 0x000FFFFF    (保留)
0x00100000 - 0x00100FFF    CLINT (核心本地中断器)
0x00101000 - 0x00101FFF    RTC
0x0C000000 - 0x0FFFFFFF    PLIC (平台级中断控制器)
0x10000000 - 0x100000FF    UART0 (NS16550A)
0x80000000 - 0x87FFFFFF    RAM (128MB)
```

### 内核内存布局

```
0x80000000                  _start (启动入口)
    |
    ├─ .text.boot           启动代码
    ├─ .text                内核代码
    ├─ .rodata              只读数据
    ├─ .data                已初始化数据
    ├─ .bss                 未初始化数据
    |
0x????????                  __stack_start
    ├─ Stack (64KB)         内核栈
0x????????                  __stack_top
    |
0x????????                  __heap_start
    ├─ Heap (1MB)           动态分配
0x????????                  __heap_end
    |
0x????????                  空闲页
    ├─ 页分配器             剩余 RAM
0x87FFFFFF                  RAM 结束
```

## 特权模式

### 机器模式（M-mode）
- 最高特权级别
- 完全硬件访问权限
- 由 OpenSBI/固件处理
- 我们的内核不直接使用

### 监管者模式（S-mode）
- 操作系统特权级别
- 我们的内核在此运行
- 可以访问大多数 CSR
- 不能直接访问 M-mode 资源

### 用户模式（U-mode）
- 最低特权级别
- 用户程序在此运行（计划中）
- 资源访问受限
- 必须使用系统调用进行特权操作

## 模块描述

### Bootloader (`bootloader/`)
- **boot.S**：初始启动的汇编代码
  - 设置栈
  - 清除 BSS
  - 跳转到内核
  - 定义陷阱入口点

### 内核核心 (`kernel/`)
- **main.c**：内核入口点和主循环
  - 系统初始化
  - 交互式 shell
  - 命令处理

- **printf.c**：格式化输出
  - printf() 实现
  - panic() 用于致命错误

- **types.h**：类型定义
- **riscv.h**：RISC-V 特定内联函数

### 内存管理 (`kernel/mm/`)
- **mm.c**：内存分配器
  - 页分配器（基于栈）
  - 堆分配器（bump 分配器）
  - 内存统计

### 进程管理 (`kernel/process/`)
- **process.c**：进程表和管理
  - 进程状态
  - 进程分配/释放
  - （调度待实现）

### 系统调用 (`kernel/syscall/`)
- **syscall.c**：系统调用处理器
  - read/write
  - fork/exec（桩函数）
  - exit

### 陷阱处理 (`kernel/trap/`)
- **trap.c**：中断和异常处理
  - 异常处理器
  - 中断处理器
  - 上下文切换（待实现）

### 驱动 (`drivers/`)
- **uart/**：NS16550A UART 驱动
  - 字符 I/O
  - 控制台支持

- **rtc/**：实时时钟
  - 时间读取

- **plic/**：平台级中断控制器
  - 中断路由
  - 优先级管理

## 数据结构

### 进程结构
```c
typedef struct process {
    uint64_t pid;           // 进程 ID
    proc_state_t state;     // 进程状态
    uint64_t *pagetable;    // 页表指针
    uint64_t context;       // 保存的上下文
    uint64_t kernel_sp;     // 内核栈指针
    uint64_t user_sp;       // 用户栈指针
} process_t;
```

### 页分配器
- 维护空闲页的链表
- 每个页指向下一个空闲页
- O(1) 分配和释放

## 中断和异常处理

### 使用的 CSR 寄存器
- `stvec`：陷阱向量基地址
- `sstatus`：监管者状态寄存器
- `sie`：监管者中断使能
- `sip`：监管者中断挂起
- `sepc`：监管者异常程序计数器
- `scause`：监管者陷阱原因
- `stval`：监管者陷阱值
- `sscratch`：监管者临时寄存器

### 陷阱流程
1. 发生异常/中断
2. CPU 切换到 `trap_entry`（在 `stvec` 中设置）
3. 保存上下文
4. 调用 `trap_handler()`
5. 确定陷阱类型（中断 vs 异常）
6. 适当处理
7. 恢复上下文
8. 通过 `sret` 返回

## 构建和编译

### 工具链
- **编译器**：`riscv64-unknown-elf-gcc`
- **链接器**：`riscv64-unknown-elf-ld`
- **目标**：RV64IMAC（64 位，带整数、乘法、原子、压缩）
- **ABI**：lp64（long 和指针是 64 位）

### 编译标志
- `-march=rv64imac`：目标架构
- `-mabi=lp64`：ABI 规范
- `-mcmodel=medany`：中等任意代码模型
- `-nostdlib`：不链接标准库
- `-fno-builtin`：不使用内置函数

### 链接
- 自定义链接器脚本（`scripts/kernel.ld`）
- 段：`.text.boot`、`.text`、`.rodata`、`.data`、`.bss`
- 栈和堆分配

## QEMU 配置

### 虚拟机
- 机器类型：`virt`
- 内存：128MB
- SMP：1 核
- 设备：UART、RTC、PLIC、CLINT

### 设备树
- 位于 `qemu/device-tree/virt.dts`
- 描述硬件布局
- 供操作系统用于设备发现（未来）

## 测试

### 手动测试
1. 构建内核：`make all`
2. 在 QEMU 中运行：`make run`
3. 测试 shell 命令：
   - `help`：列出命令
   - `info`：显示系统信息
   - `test`：测试内存分配
   - `echo hello`：回显文本
   - `reboot`：退出 QEMU

### 内存测试
- 分配页
- 分配堆内存
- 验证分配
- 释放页
- 检查泄漏

## 未来增强功能

### 虚拟内存（SV39）
- 3 级页表
- 512GB 虚拟地址空间
- 用户/内核分离

### 调度
- 轮转调度器
- 基于定时器的抢占
- 进程上下文切换

### 用户空间
- ELF 加载器
- 用户模式执行
- 系统调用接口

### 文件系统
- 简单文件系统
- VFS 层
- 设备文件

## 参考资料

- [RISC-V 规范](https://riscv.org/technical/specifications/)
- [RISC-V 特权架构](https://github.com/riscv/riscv-isa-manual)
- [QEMU RISC-V 文档](https://www.qemu.org/docs/master/system/target-riscv.html)
- [xv6-riscv](https://github.com/mit-pdos/xv6-riscv) - 参考操作系统实现
